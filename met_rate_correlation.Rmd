---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
library(readxl)
library(ggplot2)
library(ggpmisc)
library(factoextra)
library(FactoMineR)
library(PCAtools)
library(ppcor)
#install.packages('gdata')
library("ggcorrplot")
library(Hmisc)
library(ggiraphExtra)
library(ggstatsplot)
library(boot)
library(ape)
library(ade4)
library("dplyr")
library(geiger)
library(caper)
library(nlme)
library('googlesheets4')
library(gridExtra)
library('phytools')
library(colorspace)
library(car)
library(reshape2)
library(cowplot)
library(broom)
```


### Load mutation data from Cagan et al. They identified 3 different mutational signatures in the mammals and deconvolved the somatic mutation rates
```{r}
load('~/Desktop/Projects/life_expetancy_of_species/CrossSpecies2021/data/processed/Burdens_Rates.RData')
mut_rates_all=read_excel("mutation_burdens.xlsx")
strings <- c('Sample','Individual','Species','Age (years)','SBS','Substitution')
cols <- grep(paste(strings, collapse="|"), names(mut_rates_all))
mut_rates<- mut_rates_all[,cols]


mut_rates_df=data.frame()

for (species in unique(mut_rates$Species)){
    df=mut_rates[mut_rates$Species==species,]
    
    # Convert to numeric if chr column
    df <- df %>%
      mutate_if(is.character, as.numeric)
    
    ## Drop rows with Nans
    df=df[complete.cases(df$`Substitution rate per year`),]
    
    ## Calculate the weighted mean of all mutation metric columns
    mean_df=df %>% 
      group_by('Individual') %>% 
        summarise(across(.cols = -'Individual', .fns = mean))
  
    ## Add common name to the data frame as it was lost due to being a string column
    mean_df$common_name=species
    ## Add mean values of species to the main dataframe collecting the results
    mut_rates_df=rbind(mut_rates_df,mean_df)
  
}

## Drow NaN rows
mut_rates_df=mut_rates_df[complete.cases(mut_rates_df$`Substitution rate per year`),]
## Drop columns wit all NaNs
mut_rates_df= mut_rates_df[, colSums(!is.na(mut_rates_df)) ==nrow(mut_rates_df)]

## Select column with mutation rate data + common name to merge it with trait data
sbs_rates_colnames=grep(paste(c('per year','common_name','exposure'), collapse="|"), names(mut_rates_df))
mut_rates_df=mut_rates_df[,sbs_rates_colnames]

## Rename column names for an easier use
colnames(mut_rates_df)=c('SBS1_expos','SBSB_expos','SBSC_expos','subs_rate_per_year','SBS1_rate','SBSB_rate','SBSC_rate','common_name')
```

### 1. Calculate the logarithms of the life history traits and add them as new columns
### 2. Plot the associations between the life history traits

```{r fig.width=4.5, fig.height=3}

## LOAD dataset

lht=read_sheet('https://docs.google.com/spreadsheets/d/1LVjxWmLhKSexxleSL21-c6XTVvZy70rwpOo81O74hlI/edit?usp=sharing',sheet='Raw data')


## Set species name as rowname for phylogenetic analysis later
d=lht
d=as.data.frame(d)

## Check if all the species' names are in the phylogenetic tree
rownames(d)=unlist(d[,'species_name'])

## Rename columns to shorter more managable names

d[,'lifespan']=d$`Lifespan_80 (y) [Species 360/Human Mortality Database]`

d[,'spec_met_rate_per_day']=d[,'BMR (kcal/kg BW/day)']

#d[,'met_rate_lifetime']=d[,'BMR (kcal/kg BW/day)']*(d[,'Adult mass (g)']/1000)*(d[,'lifespan'])*365*4184

d[,'mutation_rate']=((d[,'Mean mutation rate']))

d[,'respiratory_rate']=((d[,'mean_respiratory_rate_brpm']))

d[,'heart_rate']=((d[,'mean_bpm']))

d[,'adult_mass']=((d[,'Adult mass (g)']))

d[,'time_to_sexual_maturity_female']=d[,'Female sexual maturity (days)']

d[,'sexual_maturity_to_lifespan_ratio_female']=d[,'time_to_sexual_maturity_female']/(d[,'lifespan']*365)

d[,'time_to_sexual_maturity_male']=d[,'Male sexual maturity (days)']

d[,'sexual_maturity_to_lifespan_ratio_male']=d[,'time_to_sexual_maturity_male']/(d[,'lifespan']*365)

d[,'sexual_maturity_ratio_male_female']=d[,'time_to_sexual_maturity_male']/d[,'time_to_sexual_maturity_female']

d[,'mass_specific_BMR']=(d$`metabolic_rate_Wg`)

d[,'basal_metabolic_rate']=as.numeric(d$`metabolic_rate_W`)

d[,'body_temperature']=d$`typical_body_temperature [Â°C]`

d[,'calculated_met_rate_W']=0.001*exp((1/303-1/310)*0.63/1.38*10^-20)*d[,'heart_rate']*d[,'adult_mass']/1000

d[,'calculated_spec_met_rate_W']=0.001*exp((1/303-1/310)*0.63/1.38*10^-20)*d[,'heart_rate']

d[,'phylogenetic_tree_main_branch']=as.factor(d$phylogenetic_tree_main_branch)


## Merge mutation rate data with life trait data
d=merge(d, mut_rates_df, by = "common_name")


## Calculate log transformation of selected  columns
cols_to_be_log_transformed=c('lifespan','mutation_rate','respiratory_rate',
                             'heart_rate','adult_mass','time_to_sexual_maturity_female','time_to_sexual_maturity_male',
                             'mass_specific_BMR','basal_metabolic_rate',
                             'SBS1_expos','SBSB_expos','SBSC_expos','subs_rate_per_year','SBS1_rate','SBSB_rate','SBSC_rate')
                             # These columns are sparse
                             #'Superoxide_production_liver','SOD_activity_liver','Superoxide_production_kidney',
                             #'H2O2_production_kidney','Superoxide_production_heart','H2O2_production_heart',
                             #'Mitochondrial_respiration_kidney','Mitochondrial_respiration_heart')

# Collect the log transformed column names in vector
log_transformed_cols=c()
for (col in cols_to_be_log_transformed){
  log_colname=paste(c('log',col),collapse='_')
  d[,log_colname]=log10(d[,col])
  log_transformed_cols=append(log_colname,log_transformed_cols)
}


## Save final dataset for analysis
columns_for_final_analysis=c('lifespan','mutation_rate','respiratory_rate','heart_rate','adult_mass',
                             'time_to_sexual_maturity_female','time_to_sexual_maturity_male','litter_size',
                             'mass_specific_BMR','basal_metabolic_rate','phylogenetic_grandorder_order',
                             'common_name','subs_rate_per_year','SBS1_rate','SBSB_rate','SBSC_rate',
                              'SBS1_expos','SBSB_expos','SBSC_expos')


write.csv(d[,columns_for_final_analysis],'dataset_for_analysis.csv',row.names=TRUE)
```


## Read phylogenetic tree data
## 1. Read tree that has been constructed using mtDNA
## 2. Read multiple trees (1000 trees from vertlife.org) into a multi-phylo object and get a consensus tree
## 2.1 There ara 3 diffetent methods to build a consensus tree 
## 3. Root trees in order to use them with caper's pgls function -> midpoint root method

```{r}
## Old tree based on whole mtDNA sequence

# New tree basen on mtDNA gene sequences concatented together
tree=read.tree('Phylogenetic_analysis/concatenated_genes_of_15_species_ALIGNED_TREE.nwk')

rooted_tree=midpoint.root(tree)


## Read the 1000 trees acquired from vertlife.org into  multi-phylo object 
multi_tree=read.nexus('Phylogenetic_analysis/1000_phyl_trees_from_vert_life.nex', force.multi = TRUE)


## Create consensus trees. More on the methods  http://blog.phytools.org/2016/03/method-to-compute-consensus-edge.html
## Rename Canis lupus (wolf) to Canis lupus familiaris (dog)

cons_mean_edge_1000=consensus.edges(multi_tree,method="mean.edge",if.absent="zero")
cons_mean_edge_1000$tip.label[grepl('Canis',cons_mean_edge_1000$tip.label)]='Canis_lupus_familiaris'
plot(midpoint.root(cons_mean_edge_1000),main='mean edge method - 1000 trees')

cons_least_squares_1000=consensus.edges(multi_tree,method="least.squares")
cons_least_squares_1000$tip.label[grepl('Canis',cons_least_squares_1000$tip.label)]='Canis_lupus_familiaris'
plot(midpoint.root(cons_least_squares_1000),main='least squares method - 1000 trees')


multi_tree_10000_dna_only=read.nexus('Phylogenetic_analysis/10000_tip_dated_DNA_only_4098_species.nex', force.multi = TRUE)
multi_tree_10000_completed=read.nexus('Phylogenetic_analysis/10000_tip_dated_completed_5911_species.nex', force.multi = TRUE)

## Drop trees which don't contain all the 15 species
multi_tree_list=list(dna_only=multi_tree_10000_dna_only,completed=multi_tree_10000_completed)

multi_tree_10000=multi_tree_10000_completed

## Check if any of the trees do not contain all 15 species and collect them
trees_to_drop=c()
    for (name in names(multi_tree_10000)){
      t=multi_tree_10000[[name]]
      if (length(t$tip.label)<15){
      trees_to_drop=append(tree_to_drop,name)
      }
    }
## Drop trees containing less then 15 species  
multi_tree_10000=multi_tree_10000[!is.element(names(multi_tree_10000),trees_to_drop)]
    
cons_mean_edge_10000=consensus.edges(multi_tree_10000,method="mean.edge",if.absent="zero")
cons_mean_edge_10000$tip.label[grepl('Canis',cons_mean_edge_10000$tip.label)]='Canis_lupus_familiaris'
plot(midpoint.root(cons_mean_edge_10000),main=paste('mean edge method - 10 000 trees',seq=' - '))
    
    
cons_least_squares_10000=consensus.edges(multi_tree_10000,method="least.squares")
cons_least_squares_10000$tip.label[grepl('Canis',cons_least_squares_10000$tip.label)]='Canis_lupus_familiaris'
    
plot(midpoint.root(cons_least_squares_10000),main=paste('least squares method - 10 000 trees',seq=' - '))


plot((cons_least_squares_10000))
plot((cons_mean_edge_10000))
```

##    1. Midpoint root the selected consensus tree for analysis with the caper package
##    2. Save and load previously created rooted consensus tree
```{r}
tree=cons_least_squares_10000

## Root the selected tree for analysis
rooted_tree=midpoint.root(tree)
plot(rooted_tree)

## Delete internal node names, as they overlap with tip-label names and cause an error with comparative-data function
rooted_tree$node.label=NULL
comp_dat=comparative.data(phy=rooted_tree, data=d, names.col=species_name, vcv = TRUE,warn.dropped = F,na.omit=F)

tree=rooted_tree

saveRDS(tree,file='rooted_tree.Rds')
```





## Load saved rooted tree
```{r}
rooted_tree=readRDS(file='rooted_tree.Rds')
#tree$node.label=NULL
comp_dat=comparative.data(phy=rooted_tree, data=d, names.col=species_name, vcv = TRUE,warn.dropped = F,na.omit=F)
tree=rooted_tree
```



### Read in Elton Traits dataset, which conatins foraging (=diet) and activity data of species
### 1. Create PCA of the elton trait (diet+activity) data
### 2. Create PCA of the original trait data 
### 3. Create PCA of elton + original trait data concatenated in one dataframe
```{r fig.width=8, fig.height=5.5}
elton_trait=read.table('Phylogenetic_analysis/elton_traits.txt',sep='\t',header=T)

## Substitute dot in colnames to underscore for later analysis
colnames(elton_trait)=gsub('\\.',"_",colnames(elton_trait))

species=gsub('_',' ',d$species_name)
species[grepl('Canis',species)]='Canis lupus'

### ubset elton trait dataframe to the 15 assessed species 
elton_trait_subset=elton_trait[is.element(elton_trait$Scientific,species),]
row.names(elton_trait_subset)=gsub(' ','_',elton_trait_subset$Scientific)
row.names(elton_trait_subset)[grepl('Canis',row.names(elton_trait_subset))]='Canis_lupus_familiaris'

## Define column names (trait names) of the original dataset 
pca_colnames_orig_data=c('log_lifespan','log_mutation_rate','log_respiratory_rate','log_heart_rate','log_adult_mass','log_time_to_sexual_maturity_female',
                        'log_time_to_sexual_maturity_male','litter_size','log_basal_metabolic_rate')

## Select colnames with Diet and Activity data in Elton Traits dataframe
pca_colnames_elton_trait=colnames(elton_trait_subset)[grepl('Diet',colnames(elton_trait))|grepl('Activity',colnames(elton_trait))]


## Extract numeric only data from dataframe containing all the elton trait data
elton_trait_pca=elton_trait_subset[,pca_colnames_elton_trait]
elton_trait_pca=dplyr::select_if(elton_trait_pca,is.numeric)


## Drop all 0 columns and calculate PCA
elton_trait_pca=elton_trait_pca[,-(which(colSums(elton_trait_pca)==0))]
elton_trait_numerical_colnames=colnames(elton_trait_pca)
res_elton_trait_pca=PCA(elton_trait_pca,graph=F)

## Subset data to original trait variables and calculate PCA
orig_trait_pca=d[,pca_colnames_orig_data]
res_orig_trait_pca=PCA(orig_trait_pca,graph=F)

## Add elton trait data to original phylogenetic trait dataframe and calculate PCA
all_trait_pca=cbind(elton_trait_pca,d[match(row.names(elton_trait_pca),d$species_name),pca_colnames_orig_data]) 
res_all_pca=PCA(all_trait_pca,graph=F)

## Add non-numeric data to dataframe of only elton trait data for pca
elton_trait_pca['species_name']=rownames(elton_trait_pca)
elton_trait_pca[,'nutrition']=d[match(row.names(elton_trait_pca),d$species_name),'nutrition']
elton_trait_pca[,'phyl_tree_main_branch']=(d[match(row.names(elton_trait_pca),d$species_name),'phylogenetic_tree_main_branch'])

## Add non-numeric data to dataframe of original traits data for pca
orig_trait_pca['species_name']=rownames(orig_trait_pca)
orig_trait_pca[,'nutrition']=d[match(row.names(orig_trait_pca),d$species_name),'nutrition']
orig_trait_pca[,'phyl_tree_main_branch']=(d[match(row.names(orig_trait_pca),d$species_name),'phylogenetic_tree_main_branch'])

## Add non-numeric data to dataframe of all traits data for pca
all_trait_pca['species_name']=rownames(all_trait_pca)
all_trait_pca[,'nutrition']=d[match(row.names(all_trait_pca),d$species_name),'nutrition']
all_trait_pca[,'phyl_tree_main_branch']=(d[match(row.names(all_trait_pca),d$species_name),'phylogenetic_tree_main_branch'])


my_cols=rainbow(3)

labels_for_pca=paste('',elton_trait_pca[,'phyl_tree_main_branch'],sep=' ')

elton_trait_pca_plot=fviz_pca_biplot(res_elton_trait_pca,axes = c(1,2),repel=T,col.ind=labels_for_pca,legend.title = 'phyl_tree_main_branch',
                      palette=my_cols,labelsize = 6,pointsize = 2,invisible="quali") +theme(text = element_text(size = 16))+ ggtitle('Elton traits PCA')

orig_trait_pca_plot=fviz_pca_biplot(res_orig_trait_pca,axes = c(1,2),repel=T,col.ind=labels_for_pca,legend.title = 'phyl_tree_main_branch',
                      palette=my_cols,labelsize = 6,pointsize = 2,invisible="quali") +theme(text = element_text(size = 16))+ ggtitle('Oiriginal traits PCA')

all_trait_pca_plot=fviz_pca_biplot(res_all_pca,axes = c(1,2),repel=T,col.ind=labels_for_pca,legend.title = 'phyl_tree_main_branch',
                      palette=my_cols,labelsize = 6,pointsize = 2,invisible="quali") +theme(text = element_text(size = 16))+ 
                      ggtitle('Elton + original traits PCA')

print(elton_trait_pca_plot)
print(orig_trait_pca_plot)
print(all_trait_pca_plot)
```


###   Plot the univariate linear regressions between the variables and lifespan
####  Select which phylogenetic correction package (ape vs. caper) is used in the PGLS fitting
```{r fig.width=6, fig.height=4.5}

#d=cbind(d,elton_trait_pca[match(d$species_name,row.names(elton_trait_pca)),])

comp_dat=comparative.data(phy=rooted_tree, data=d, names.col=species_name, vcv = TRUE,warn.dropped = F,na.omit=F)

## Determine which cols should be plotted in linear regression plots
life_traits=c('mutation_rate','respiratory_rate','heart_rate','adult_mass','time_to_sexual_maturity_female',
              'time_to_sexual_maturity_male','litter_size','basal_metabolic_rate','mass_specific_BMR',cols_to_be_log_transformed)

log_life_traits=colnames(d)[grepl('log_',colnames(d))]

## Drop log_liter_size, as litter_size is not assessed as a logarithmic trait + add elton trait colnames
assessed_traits=c(log_life_traits[which(log_life_traits!='log_litter_size')],'litter_size')
  
life_traits_list=list(life_traits=life_traits,log_life_traits=log_life_traits,assessed_traits=assessed_traits)


## select which phylogenetic method is used for the PGLS curve fitting. 
## - ape fits Pagel's lamba values, that are out of the 0-1 range that makes bioigcal sense,<-> no rooted tree needed
## - caper fits Pagel's lamba values in the range of 0-1 and gives significance values + confidence intervals <-> needs a rooted tree  
pgls_fit_package='caper' 


for (n in  3:length(names(life_traits_list))){ 
  cols=life_traits_list[[names(life_traits_list)[n]]]
    for (y_val in c('log_lifespan','log_mass_specific_BMR')){ #'log_SBSC_rate','log_SBS1_rate','log_SBSB_rate'
      
      lambda_estimate_df=data.frame()
      for (x_val in cols[!grepl(y_val,cols)]){
        
        form=as.formula(paste(c(y_val,x_val),collapse='~'))
        
        
        
        if (pgls_fit_package=='ape'){
          
          ## Fit Brownian motion model (with fixed Pagel's lambda==1) -> if fixed=False, then estimated lambda values are used 
          phyl_lm=gls(model=form,data=d,correlation = corPagel(value=1,phy=tree,form=~species_name,fixed =T),
                               method='ML',control=glsControl(opt="optim"))
          
          ## Estimate lambda values (fixed==F)
          lambda_estimate=gls(model=form,data=d,correlation = corPagel(value=1,phy=tree,form=~species_name,fixed =F),
                               method='ML',control=glsControl(opt="optim"))
          print(x_val)
          print(((lambda_estimate$modelStruct)))
          cat('\n')
          
          ## Plot maximum likelihood curves of lambda values
          lambda <- seq(0, 1, length.out = 50)
          lik <- sapply(lambda, function(lambda) logLik(gls(form,correlation = corPagel(value = lambda, phy = tree, fixed = T,form=~species_name),
          data = d,control=glsControl(opt="optim"))))
          plot(lik ~ lambda, type = "l", main = (paste("Likelihood Plot for ",x_val)), ylab = "Log Likelihood", xlab = expression(lambda))
          abline(v = lambda_estimate$modelStruct, col = "red")
          
          ## Extract estimated lambda value and add it to the dataframe
          lambda_estim_val=unlist(lambda_estimate$modelStruct[[1]])[1]
          lambda_estimate_df=rbind(lambda_estimate_df,data.frame(opt=lambda_estim_val))
          
          ## Calculate r-squared of the phylogenetically corrected model
          r_squared=1-(sum((phyl_lm[['residuals']][1:nrow(d)])^2)/sum((d[,y_val]-mean(d[,y_val]))^2))
          
          ## Calculate P-value of phyl. corrected regression (p-value of Beta equals p-value of R-squared in univariate regression)
          corr_p_val=summary(phyl_lm)$tTable[x_val,'p-value']
          
          ## Extract fitted values
          fitted_values=phyl_lm$fitted
          }
        
        
        if (pgls_fit_package=='caper'){
          
          ## Fit Brownian motion model (with fixed Pagel's lambda==1)
          phyl_lm=pgls(form,data = comp_dat, lambda = 1)
          
          ### Estimate Pagel's lambda values
          ## Calculate the estimates of the Lambda values with caper's pgls function and collect the results to  a dataframe
          phyl_lm_lambda_estim=pgls(form,data = comp_dat, lambda = "ML")
          lambda_estimates=summary(phyl_lm_lambda_estim)$param.CI$lambda[1:4]
          
          ## Plot maximum likelihood curves of lambda values
          #plot(pgls.profile(phyl_lm_lambda_estim, "lambda"),main=format(form))
          
          ## Extract estimated lambda value and add it to the dataframe
          lambda_estim_val=round(unlist(summary(phyl_lm_lambda_estim)$param.CI$lambda[1]),2)
          lambda_estimate_df=rbind(lambda_estimate_df,data.frame(x_val=x_val,lapply(lambda_estimates,round,4)))
          
          
          ## Calculate r-squared of the phylogenetically corrected model
          r_squared=summary(phyl_lm)$r.squared
          
          ## Calculate P-value of phyl. corrected regression (p-value of Beta equals p-value of R-squared in univariate regression)
          corr_p_val=summary(phyl_lm)[['coefficients']][x_val,'Pr(>|t|)']
          
          ## Extract fitted values
          fitted_values_mat=phyl_lm[['fitted']]
          fitted_values_mat=fitted_values_mat[match(d$species_name,rownames(fitted_values_mat)),]
          fitted_values=c(fitted_values_mat)

        }
        

        pearson_res <- cor.test(unlist(d[,x_val]), unlist(d[,y_val]),method = "pearson")
        spearman_res <- cor.test(unlist(d[,x_val]), unlist(d[,y_val]),method = "spearman",exact=F)
        
        
        my.formula <- y ~ x
        plot_df=d
        plot_df[,'fitted']=fitted_values
        #plot_df=plot_df[!is.element(rownames(plot_df),c('Homo_sapiens')),]


        p=ggplot(data=plot_df,aes_string(x=x_val,y=y_val))+geom_point(aes(colour=(phylogenetic_grandorder_order)))+
        geom_smooth(formula = my.formula,method='lm')+
        #geom_line(aes_string(x=x_val,y='fitted'),size=1)+
        stat_poly_eq(formula = my.formula,
                        aes(label = paste(..eq.label.., ..rr.label..,'p-value:',round(..p.value..,6),
                                          expression(paste('R'['corr']^2,'=')),round(r_squared,2),
                                          expression(paste('p-value'['corr'],'=')),
                                          round(corr_p_val,6),
                                          expression(lambda),lambda_estim_val,sep='~~~')),
                        parse = T,show.legend=T) +
        geom_text_repel(aes_string(label = '`common_name`'))+
        annotate('label',x=0.9*max(d[,x_val]),y=0.85*max(d[,y_val]),
                   label=paste('Pearson: R = ',round(pearson_res$estimate,2),', p-value = ',round(pearson_res$p.value,6),
                   "\nSpearman: R = ", round(spearman_res$estimate, 2), ", p-value = ", round(spearman_res$p.value,6),sep=''))+
        ggtitle(x_val)+ theme(axis.title.x=element_text(size=20),axis.title.y=element_text(size=20))#+
        # scale_color_manual(name='Models',
        #                   breaks=c('No correction', 'Phylogeny \ncorrected'),
        #                   values=c('No correction'='blue', 'Phylogeny \ncorrected'='black'))
        print(p)
  
      }
  }
}
print(lambda_estimate_df)

```


###   Fit linear models to the data in order to detect if there are any more variables besides mutation rate that can explain significant variation in        lifespan
##    1. Dependent variable is log_lifespan (can be changed)
##    2. Fixed independent variable is log_mutation_rate 
##    3. Loop throught the other variables and fit a multivariate (or univariate if required) linear model (dependent variable~independent variable(s))
##    3.1 If phylogenetic correction is required, then linear model is a phylogenetic least squares (gls function) with phylogenetic tree of the 15 species
##    3.2 Estimate the phylogenetic signal with caper's pgls function. If lambda==0 ->no phyl. signal, if lambda==1 ->Brownian-motion. P-values of          likelihood ratio-tests (whether estimated lambda is significantly different from 0 or 1) are also calculated, along with confidence intervals of        the estimated lambda (see https://www.google.com/https://s3-eu-west-1.amazonaws.com/pfigshare-u-files/3244241/PGLSProblemSet2014.pdf )  

##    4. Collect results to a dataframe (!!!! result_df !!!!), where rows are the names of the variables that were used as independent vars in the             model
##    - The two fitted values (beta and p-value) of variables that were looped through are saved in the columns with the name: "beta_var" and                 "p_value_var"
##    - If fixed independent variables were used, their results are in the "beta_name_of_fixed_var" and "p_value_name_of_fixed_var"

```{r fig.width=4.5, fig.height=3}
## Select variables (==column names) for the analysis 
lm_colnames=c('log_mutation_rate','log_respiratory_rate','log_heart_rate','log_adult_mass','log_time_to_sexual_maturity_female',
              'log_time_to_sexual_maturity_male','litter_size','log_mass_specific_BMR')

#lm_colnames=assessed_traits

## Select dependent (default:lifespan ) and fixed independent variables (default: mutation rate) -> you can play around with others as well ofc
dependent_vars=c('log_lifespan')
fixed_independent_vars=c('log_mutation_rate','log_adult_mass')

## Decide if phylogenetic correction should be considered in the linear model fitting ('yes'/'no')
phylogenetic_correction='yes'

## Functions that help to initialize and collect the data into the  dataframe that will hold the results

# Add prefix to the variable name -> two fitted values of the regression: Beta and p-value
add_prefix=function(x){
  beta=paste(c('beta',x),collapse = '_')
  p_val=paste(c('p_value',x),collapse = '_')
  return(c(beta,p_val))
}

# Collect the two fitted values (beta and p-value) from the summary of the fitted model and add them to the dataframe containing all the results
collect_results=function(result_df,lm_coef_matrix,var,fixed_independent_vars){
    result_df_prefixes=c('beta','p_value')
    
    for (var_name in c(var,fixed_independent_vars)){
      if (var_name==var){
        res_col_varname='var'}
      else {res_col_varname=var_name}
      
      cat('\n')
      for (n in 1:length(colnames(lm_coef_matrix))){
        coef_matr_coln=colnames(lm_coef_matrix)[n]
        prefix=result_df_prefixes[n]
        
        res_coln=paste(c(prefix,res_col_varname),collapse='_')
        result_df[var,res_coln]=lm_coef_matrix[var_name,coef_matr_coln]}
    }
  return(result_df) 
}


## Add prefix to the variable name
result_df_colnames=unlist(lapply(c('var',fixed_independent_vars),FUN=add_prefix))

# Select column names (=variables) to loop through -> drop the variables that are used for the model fitting
colnames_to_loop=lm_colnames[!is.element(lm_colnames,c(dependent_vars,fixed_independent_vars))]

## Initialize the dataframe that will hold the results of the analysis
result_df=data.frame(matrix(NA,nrow=length(colnames_to_loop),ncol=length(result_df_colnames),dimnames=list(colnames_to_loop,result_df_colnames)))


## Loop through the variables
for (phylogenetic_correction in c('no')){
  
  ## Initialize dataframe which will collect the estimates of the lambda values,confidence intervals,
  ## p-values of likelihood ratio-tests (whether estimated lambda is significantly different from 0 (=no phyl. signal) or 1(=Brownian-motion))
  lambda_estimate_df=data.frame()
  lambdas=list()
  lambdas_caper=list()
  for (var in colnames_to_loop){

    # Drop datapoints that are NAN and select only numeric columns + necessary metadata: 
    # Species common name + nutrition + litter_size + body_temperature
    df=d[!is.na(d[,var]),]
    df=as.data.frame(df)
    df=df[,c(log_transformed_cols,assessed_traits,'common_name','species_name','nutrition','litter_size','body_temperature')]
  
    
    ## Create formula for the linear model fitting
    form=as.formula(paste(c(dependent_vars,c(paste(c(fixed_independent_vars,var),collapse = '+'))),collapse='~'))
  
    ## If no phylogenetic correction, use regular linear regression (lm function) and collect results to result_df
    if (phylogenetic_correction=='no'){
      lm_model=lm(formula=form,data=df)
      lm_coef_matrix=summary(lm_model)$coefficients[,c('Estimate','Pr(>|t|)')]
      result_df=collect_results(result_df,lm_coef_matrix,var,fixed_independent_vars)
      phyl_corr='without phylogenetic correction'
      
      print(var)
      print('Variance inflation factors')
      print(form)
      print(vif(lm_model))
      print(paste('adj.R-squared:',summary(lm_model)$adj.r.squared))
      }
  
    ## If phylogenetic correction is wanted, use phylogenetic least squares (gls function) with phylogenetic tree of the 15 species
    ## and collect results to result_df
    if (phylogenetic_correction=='yes'){
      # pgls_model=gls(form,data=df,correlation=corBrownian(phy=tree,form=~species_name),method='ML')
      # pgls_model=gls(model=form,data=d,correlation = corPagel(value=1,phy=tree,
      #                                                        form=~species_name,fixed = T),method='ML',
      #                control=glsControl(opt="opt",optimMethod='BFGS'))
      # lm_coef_df=as.data.frame(summary(pgls_model)[['tTable']])[,c('Value','p-value')]
      # result_df=collect_results(result_df,lm_coef_df,var,fixed_independent_vars)
      # phyl_corr='with phylogenetic correction'
      # lambdas=append(lambdas,unlist(pgls_model$modelStruct[[1]])[1])
      
      phyl_lm_caper_lambda_estim=pgls(form,data = comp_dat, lambda = 1)
      lm_coef_df=as.data.frame(summary(phyl_lm_caper_lambda_estim)$coefficients[,c('Estimate','Pr(>|t|)')])
      result_df=collect_results(result_df,lm_coef_df,var,fixed_independent_vars)
      
      lambda_estimates=summary(phyl_lm_caper_lambda_estim)$param.CI$lambda[1:4]
      #lambda_estimate_df=rbind(lambda_estimate_df,data.frame(var=var,lapply(lambda_estimates,round,4)))
      lambdas_caper=append(lambdas_caper,unlist(summary(phyl_lm_caper_lambda_estim)$param.CI$lambda[1]))
      #plot(pgls.profile(phyl_lm_caper_lambda_estim, "lambda"),main=format(form))
      cat('\n')
      }
    }
  
  
  result_df['var_name']=rownames(result_df)
  result_df['adj_p_value']=p.adjust(result_df[,'p_value_var'],method='BH')
  result_df[,'lambda']=unlist(lambdas)
  result_df[,'lambda_caper']=unlist(lambdas_caper)
  
  ## Print the fitted regression coefficients on the y-axis as barplots and indicate their adjusted P-values 
  p=ggplot(result_df,aes(x=reorder(var_name,beta_var),y=(beta_var),fill=adj_p_value)) + 
        geom_bar(stat="identity",aes(color = adj_p_value <0.2 )) +
        geom_text(aes(label=round(beta_var,2),vjust=0.5-sign(beta_var)),position=position_dodge(width=0.9), size=3)+
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.title.x=element_blank())+
        ylab('Regression coefficients')+
        ggtitle(paste(c('Regression coefficients',phyl_corr),collapse=' '))+
        ylim(-1, 1)
  print(p)
  
  
  ## Print the adjusted P-values on the y-axis
  p1=ggplot(result_df,aes(x=reorder(var_name,adj_p_value),y=(adj_p_value))) + 
        geom_bar(stat="identity",aes(color = adj_p_value <0.2 )) +
        geom_text(aes(label=round(adj_p_value,6),vjust=0.5-sign(adj_p_value)),position=position_dodge(width=0.9), size=3)+
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.title.x=element_blank())+
        ylab('Adjusted P-value of regression coeff.')+
        ggtitle(paste('Adj. P-value of regression coefficient',phyl_corr,sep=' '))+
        ylim(0, 1)
  print(p1)
  
  print(result_df)
  
  if (phylogenetic_correction=='yes'){
    print(lambda_estimate_df)}
  #grid.arrange(p, p1, ncol = 2)
}
```


#### Quality check of multivariate linear regression with/without phylogenetic correction
```{r fig.width=15, fig.height=60}
library(ggpubr)
library(lemon)
library(colorspace)
library(ggplot2)

# function to extract legend from plot
get_only_legend <- function(plot) {
  plot_table <- ggplot_gtable(ggplot_build(plot))
  legend_plot <- which(sapply(plot_table$grobs, function(x) x$name) == "guide-box")
  legend <- plot_table$grobs[[legend_plot]]
  return(legend)
}

## Variables to consider
lm_colnames=c('log_mutation_rate','log_respiratory_rate','log_heart_rate','log_adult_mass','log_time_to_sexual_maturity_female',
                        'log_time_to_sexual_maturity_male','litter_size','log_basal_metabolic_rate') #,'log_mass_specific_BMR')

## Dependent variables in linear model
dependent_vars=c('log_lifespan')

## Figure names
figure_names=c('Supplementary Figure 1','Supplementary Figure 2')

## Figure subtexts
figure_subtext=c("Diagnostic plots (QQplot, Resiudal plot, Scale-Location plot) of the fitted univariate models. The first rows show the diagnostic plots \nfor the ordinary least squares (OLS) models, where Pagel's lambda=0 meaning statistical independence between the species. The \nsecond row of plots belong to the phylogenetic generalised least squares model (PGLS) where the Pagel's lambda parameter was \nset to a fixed value of 1, assuming a Brownian-motion model of evolution and a strong phylogenetic signal.",
                 "Diagnostic plots (QQplot, Resiudal plot, Scale-Location plot) of the fitted multivariate models. The first rows show the diagnostic plots \nfor the ordinary least squares (OLS) models, where Pagel's lambda=0 meaning statistical independence between the species. The \nsecond row of plots belong to the phylogenetic generalised least squares model (PGLS) where the Pagel's lambda parameter was \nset to a fixed value of 1, assuming a Brownian-motion model of evolution and a strong phylogenetic signal.")

## Create list with fixed independent variable names. This/These variable(s) will be used as a fixed independent variable(s) in the model alongside one additional independent variable that is added to the formula. If fixed independent variable==NULL, then only the additional independent variable as considered in the model

fixed_independent_varnames=list(NA,'log_mutation_rate')

## Create list for the letters used for labeling the subplots
subplot_letters=c('a','b','c','d','e','f','g','h')

for (n in 1:length(figure_names)){
  ## Set figure name
  fig_name=figure_names[n]
  fig_subtext=figure_subtext[n]
  
  ## Fixed independent variables in linear model
  fixed_independent_vars=fixed_independent_varnames[n]
  
  ## Select column names (=variables) to loop through -> drop the variables that are used for the model fitting
  colnames_to_loop=lm_colnames[!is.element(lm_colnames,fixed_independent_vars)]
  
  ## Subset the subplot letters to the number of variables (number of subplots is equal to number of variables used as independent variables)
  fig_subplot_letters=subplot_letters[1:length(colnames_to_loop)]
  
  ## Create list to collect the grid object of plots (3x2 subplots per object) into -> all the subplots of a figure
  subplot_list=list()
  
  for (k in 1:length(colnames_to_loop)){
      ## Set the variable that is used in modelling
      var=colnames_to_loop[k]
      subplot_letter=fig_subplot_letters[k]
      
      ## Create formula dependent_var ~ fixed_independent_vars + var
      ## If fixed_independent_vars==NA, then just consider dependent_vars~var in model, so the 'NULL' won't show as string later in figure subtitle
      if (is.na(fixed_independent_vars)==TRUE){
        fo=as.formula(paste(c(dependent_vars,var),collapse='~'))
      } else {
        fo=as.formula(paste(c(dependent_vars,c(paste(c(fixed_independent_vars,var),collapse = '+'))),collapse='~'))}
 
      
      ## Fit OLS linear model
      lm_model=lm(formula=fo,data=d)
  
      ## Fit phylogenetic generalised linear model (PGLS) with a fixed lambda value=1 
      ## -> This assumes a strong phylogenetic signal (==Brownian-motion evolution model of the traits)
      pgls_model=pgls(fo,data = comp_dat, lambda = 1)
      
      ## Create list of models to loop through
      model_list=list(lm_model,pgls_model)
      names(model_list)=c("No phylogenetic signal (Pagel's lambda=0)","Strong phylogenetic signal (Pagel's lambda=1)")
      
      ## Create list to collect individual plots into
      individual_plot_list=list()
      
      for (model_name in names(model_list)){
        model=model_list[[model_name]]
      
        dd=data.frame(resid(model))
        colnames(dd)='residuals'
        dd[,'common_name']=d[base::match(rownames(dd),d$species_name),'common_name']
        dd[,'phylogenetic_grandorder_order']=d[base::match(dd$common_name,d$common_name),'phylogenetic_grandorder_order']
        dd[,'fitted']=fitted(model)
        dd[,'scaled_residuals']=scale(dd[,'residuals'])
        dd[,'sqrt_abs_std_residuals']=sqrt(abs(scale(dd[,'residuals'])))
        
        
        ## Calcluate QQplot x and y axis values, and then add them to a dataframe in order to label the species afterwards in further plots
        ## as point labeling is not available in stat_qq
        p=ggplot(data=dd,aes(sample=scaled_residuals)) +  # Create QQplot with ggplot2 package
              stat_qq()+
              stat_qq_line()
        
        ## Save the x and y values from QQplot and add them to the data (order them as the data)
        ordered_resid_df=ggplot_build(p)$data[[1]]
        dd[,'x']=ordered_resid_df[order(match(ordered_resid_df$y,dd$scaled_residuals)),'x']
        dd[,'y']=ordered_resid_df[order(match(ordered_resid_df$y,dd$scaled_residuals)),'y']

        ## Initialize plot text fontsizes  
        plot_title_size=20
        axis_label_size=20
        axis_text_size=17
        legend_text_size=20
        point_size=3
        plot_text_size=6
        my_cols=qualitative_hcl(length(unique(d$phylogenetic_grandorder_order)),palette = "Dark 3")
        labels_for_legend=factor(d[,'phylogenetic_grandorder_order'],
                                 levels=c('Carnivora','Ungulata','Rodentia','Lagomorpha','Primates'))
  
        
        ## Plot QQplot and save it to list
        p1=ggplot(data=dd,aes_string(x='x',y='y',color='phylogenetic_grandorder_order'))+geom_point(size=point_size)+
                  geom_text_repel(label = dd$common_name,size=plot_text_size)+
                  ggtitle(paste('QQplot','\n',model_name,sep=' '))+
                  stat_qq_line(aes_string(sample='y'),col = "black")+
                  theme(plot.title = element_text(size=plot_title_size,face='bold',hjust = 0.5),
                        axis.text.x=element_text(size=axis_text_size),
                        axis.title.x=element_text(size=axis_label_size),
                        axis.text.y=element_text(size=axis_text_size),
                        axis.title.y=element_text(size=axis_label_size))+
                  xlab('Theoretical quantiles')+ylab('Sample quantiles')+
                  scale_color_manual(name = '',breaks=levels(labels_for_legend),values= my_cols)+
                  theme(legend.position="none")
        
      
        individual_plot_list[paste(var,model_name,'qqplot',sep='_')]=list(p1)
        
        
        ## PLot residual plot and save it to a list
        p2=ggplot(data=dd,aes(x=fitted,y=scaled_residuals,color=phylogenetic_grandorder_order))+
                  geom_point(size=point_size,show.legend = FALSE)+
                  geom_text_repel(label = dd$common_name,size=plot_text_size)+
                  stat_plsmo(aes(x=fitted,y=residuals),inherit.aes=FALSE)+
                  ggtitle(paste('Residual plot','\n',model_name,sep=' '))+
                  theme(plot.title = element_text(size=plot_title_size,face='bold',hjust = 0.5),
                        axis.text.x=element_text(size=axis_text_size),
                        axis.title.x=element_text(size=axis_label_size),
                        axis.text.y=element_text(size=axis_text_size),
                        axis.title.y=element_text(size=axis_label_size))+
                  scale_color_manual(name = '',breaks=levels(labels_for_legend),values= my_cols)+
                  theme(legend.position="none")+
                  ylim(c(-2.5,2.5))+
                  ylab('Scaled residuals')
        
        individual_plot_list[paste(var,model_name,'residual_plot',sep='_')]=list(p2)
        
        ## PLot Scale-location plot
        p3=ggplot(data=dd,aes(x=fitted,y=sqrt_abs_std_residuals,color=phylogenetic_grandorder_order))+
                  geom_point(size=point_size)+
                  geom_text_repel(label = dd$common_name,size=plot_text_size)+
                  stat_plsmo(aes(x=fitted,y=sqrt_abs_std_residuals),inherit.aes=FALSE)+
                  ggtitle(paste('Scale-location','\n',model_name,sep=' '))+
                  theme(plot.title = element_text(size=plot_title_size,face='bold',hjust = 0.5),
                        axis.text.x=element_text(size=axis_text_size),
                        axis.title.x=element_text(size=axis_label_size),
                        axis.text.y=element_text(size=axis_text_size),
                        axis.title.y=element_text(size=axis_label_size))+
                  scale_color_manual(name = '',breaks=levels(labels_for_legend),values= my_cols)+
                  ylim(c(0,2))+
                  ylab(bquote(sqrt('|Scaled residuals|')))+
                  theme(legend.position="none")
        
        individual_plot_list[paste(var,model_name,'scale_location_plot',sep='_')]=list(p3)
        
        
        ## Create ggplot object just to extract its legend
        plot_for_legend=ggplot(data=dd,aes(x=fitted,y=residuals))+
                  geom_point(aes(color=phylogenetic_grandorder_order))+
                  theme(legend.text=element_text(size=legend_text_size,face='bold'))+
                  scale_color_manual(name = '',labels = levels(labels_for_legend),values= my_cols)+
                  guides(fill=guide_legend(title=''),
                         color = guide_legend(override.aes = list(size = 5)))
        
        ## Extract legend
        combined_legend=get_only_legend(plot_for_legend)
        
      }
      ## Create grid of 6 plots
      plots=plot_grid(plotlist = individual_plot_list,ncol = 3)
      
      ## Add legend to the plot
      plots_with_legend=plot_grid(plots,combined_legend,ncol=2,rel_widths = c(1, .068))
      
      ## Create title to subplot
      title_string=tools::toTitleCase(tolower(gsub('_',' ',format(fo))))
      title_string=gsub('Mass Specific Bmr','Mass-Specific BMR',title_string)
      subplot_title <- ggdraw() + draw_text(subplot_letter, x=0.05,y=0.5,size = 65,fontface='bold') + draw_label(title_string, size = 35,fontface='bold') 
      
      ## Add title to subplot
      plots_with_legend_title=plot_grid(subplot_title, plots_with_legend, ncol=1, rel_heights=c(0.06, 1),scale = 0.95)
      
      ## Add subplot to the list of subplots that contains all the subplots for the figure
      subplot_list[[subplot_letter]]=(as.ggplot(plots_with_legend_title))
    }
    
    ## Create figure where with all the subplots in one main plot
    figure_plot=plot_grid(plotlist=subplot_list,ncol=1)
    
    ## Create and add figure name and subtext to figure
    figure_title=ggdraw() + draw_text(fig_name, x=0.23,y=0.8,size = 65,fontface='bold') + 
                draw_label(fig_subtext, size = 32,hjust = 0, vjust = 0.08, x=0.056,y=0.008)
    figure_plot_with_title=plot_grid(figure_title, figure_plot, ncol=1, rel_heights=c(0.026, 1),scale = 0.97)
    
    ## Save figure as pdf
    ggsave2(filename=paste0('life_expectancy_figs/',fig_name,'.pdf'),plot=figure_plot_with_title,limitsize = FALSE)
    
    print(figure_plot_with_title)
  
}
```

### Chek the significance of residuals the traits after regressing the effect of mutation rate out of lifespan (=partial regression of the traits with lifespan wtihout the effect of mutation rate)

### Perform partial correlation on the dataset 
# 1. Select variable(s) that you want to regress out (var_to_regress_out)

# 2. Select variable that you want to check the residual correlation with (var_to_correlate_with)

# 3. Loop through the remaining vars and fit a linear regression model for "var_to_correlate_with~var_to_regress_out" and "var~var_to_regress_out"

# 3.1 Phylogenetic correction is possible when fitting the linear model. Phyl. correction takes the phylogenetic tree into consideration, which means that the species are not statistically independent from each other, as species more closely related tend to have similar traits. If 'phylogenetic_correction'=='yes', then the linear model fitted in 3. is a Phylogenetic generalised linear model, not a regular linear regression model

# 4. Collect the residuals from both models (residuals of var_to_correlate_with and residuals of var )

# 5. Correlate the residuals with each other -> this gives you the partial correlation between 'var_to_correlate_with' and 'var' without the effects of 'var_to_regress_out'

```{r fig.width=4, fig.height=4}

### Names of the variables we want to include in the analysis
partial_corr_colnames=c('log_lifespan','log_mutation_rate','log_respiratory_rate','log_heart_rate','log_adult_mass','log_time_to_sexual_maturity_female',
                        'log_time_to_sexual_maturity_male','litter_size','mass_specific_BMR')#'log_mass_specific_BMR')#,'log_basal_metabolic_rate')

#partial_corr_colnames=c('lifespan','mutation_rate','respiratory_rate','heart_rate','adult_mass','time_to_sexual_maturity_female',
#                        'time_to_sexual_maturity_male','litter_size','mass_specific_BMR')


#partial_corr_colnames=assessed_traits

### Determine if phylogenetic correction is wanted
phylogenetic_correction='no'


### Select variables to regress out
var_to_regress_out=c('log_mutation_rate')
#log_adult_mass,'log_basal_metabolic_rate',log_mass_specific_BMR,log_mutation_rate,'log_mutation_rate','mass_specific_BMR'


### Select variable to correlate with (=variable on the y-axis)
var_to_correlate_with=c('log_lifespan') # log_lifespan,log_mass_specific_BMR,log_heart_rate

## Create list of variables to loop through -> drop the variables that are used in regression
vars_to_loop_through=partial_corr_colnames[!is.element(partial_corr_colnames,c(var_to_regress_out,var_to_correlate_with))]

## Initialize dataframe to collect the partial perason correlation results into if no phylogenetic correction
partial_pearson_corr_result_df=data.frame(matrix(NA,ncol=4,nrow=length(vars_to_loop_through),
                                                 dimnames=list(vars_to_loop_through,c(NA,NA,NA,NA))))
colnames(partial_pearson_corr_result_df)=c("Pearson's R",'Pearson p-value',"Spearman's R",'Spearman p-value')

d_after_partial_corr=data.frame(matrix(NA,ncol=length(vars_to_loop_through),nrow=nrow(d),
                                                 dimnames=list(rownames(d),vars_to_loop_through)))
### Loop through remaining variables and perform the steps described above in points 3-5.
for (var in vars_to_loop_through){

  # Drop datapoints that are NAN and select only numeric columns + necessary metadata: 
  # Species common name + nutrition + litter_size + body_temperature
  df=d[!is.na(d[,var]),]
  df=as.data.frame(df)
  df=df[,c(partial_corr_colnames,'common_name','species_name','nutrition','body_temperature')]
  df=df[!is.element(rownames(df),c('Felis_catus')),] #'Felis_catus'
 

  ###  Create linear models in order to regress out variables
  # Create formula necessary for regressing out 'var_to_regress_out'
  vars_to_regress_out_form=paste(var_to_regress_out,collapse='+')
  form_regress_out=as.formula(paste(c(var_to_correlate_with,vars_to_regress_out_form),collapse='~'))
  # Create formula necessary for regressing out 'var'
  form_var=as.formula(paste(c(var,vars_to_regress_out_form),collapse='~'))
  
  # Check if phylogenetic correction is yes/no
  if (phylogenetic_correction=='no'){
    # Create linear model with 'var_to_regress_out' as independent variables
    lm_for_y_axis_residual_plot=lm(formula=form_regress_out,data=df)
    
    # Create linear model with 'var' as independent variables
    lm_for_x_axis_residual_plot=lm(formula=form_var,data=df)
    
    # Save the residual of 'var_to_correlate_with' to the dataframe
    df[,'y_axis_residuals']=(resid(lm_for_y_axis_residual_plot))
    d_after_partial_corr[,var_to_correlate_with]=(resid(lm_for_y_axis_residual_plot))
    
    # Save the residual of 'var' to the dataframe
    df[,'x_axis_residuals']=(resid(lm_for_x_axis_residual_plot))
    d_after_partial_corr[,var]=(resid(lm_for_x_axis_residual_plot))
    
    
    ## Execute partial correlation function and save + print result
    pearson_res=(pcor.test(df[,var_to_correlate_with],df[,var],df[,var_to_regress_out],method = 'pearson'))
    pearson_r=pearson_res$estimate
    pearson_p_value=pearson_res$p.value
    
    spearman_res=(pcor.test(df[,var_to_correlate_with],df[,var],df[,var_to_regress_out],method = 'spearman'))
    spearman_r=spearman_res$estimate
    spearman_p_value=spearman_res$p.value
    
    ## Add results to dataframe
    partial_pearson_corr_result_df[var,]=c(pearson_r,pearson_p_value,spearman_r,spearman_p_value)
    
    # Crate title of plot
    plot_title=paste(c('Corrected for:',paste(var_to_regress_out,collapse='+')),collapse=' ')
    
    #print(paste(c('partial correlation of',var,'with',var_to_correlate_with),collapse = ' '))
    #print(unlist(pearson_res[,c('estimate','p.value')]))
    #cat('\n')
    
  }
  else if(phylogenetic_correction=='yes'){
    # Create linear model with 'var_to_regress_out' as independent variables
    lm_for_y_axis_residual_plot=pgls(form_regress_out,data = comp_dat, lambda = 1)
  
    # Create linear model with 'var' as independent variables
    lm_for_x_axis_residual_plot= pgls(form_var,data = comp_dat, lambda = 1)
   
    
    # Save the residual of 'var_to_correlate_with' to the dataframe
    df[,'y_axis_residuals']=(resid(lm_for_y_axis_residual_plot))
  
    # Save the residual of 'var' to the dataframe
    df[,'x_axis_residuals']=(resid(lm_for_x_axis_residual_plot))
    
    ### Calculate Pearson's R and its P-value of the resdiuals computed with phylogenetic contrasts
    pearson_r=cor(df$x_axis_residuals,df$y_axis_residuals,method='pearson')
    num_of_cols_to_regress_out=length(var_to_regress_out)
    
    # Calculation of statistic and p-value based on partial correlation calculation in pcor.test function
    t_statistic=pearson_r*sqrt((nrow(df)-2-num_of_cols_to_regress_out)/(1-pearson_r^2))
    pearson_p_value = 2 * pt(-abs(t_statistic), (nrow(df) - 2 - num_of_cols_to_regress_out))
    
    ### Calculate Spearman's R and its P-value of the resdiuals computed with phylogenetic contrasts
    spearman_r=cor(df$x_axis_residuals,df$y_axis_residuals,method='spearman')
    # Calculation of statistic and p-value based on partial correlation calculation in pcor.test function
    t_statistic=spearman_r*sqrt((nrow(df)-2)/(1-spearman_r^2))
    spearman_p_value = 2 * pt(-abs(t_statistic), (nrow(df) - 2-num_of_cols_to_regress_out))
    
    # Crate title of plot
    plot_title=paste(c('Corrected for:',paste(c(var_to_regress_out,'phylogeny'),collapse='+')),collapse=' ')
  }
  

   ### Visualize residuals after regressing out 'var_to_regress_out' from 'var_to_correlate_with' and 'var'
  my.formula <- y ~ x
  p=ggplot(data=df,aes_string(x='x_axis_residuals',y='y_axis_residuals'))+geom_point()+
  geom_smooth(formula = my.formula,method='lm')+
  stat_poly_eq(formula = my.formula, aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                      parse = TRUE,show.legend=T) +
  geom_text_repel(aes(label=`common_name`))+
  annotate('label',x=0.6*max(df[,'x_axis_residuals']),y=0.9*max(df[,'y_axis_residuals']),
                 label=paste("Pearson's R = ",round(pearson_r,2),', p-value= ',round(pearson_p_value,8),
                 "\nSpearman's R = ", round(spearman_r, 2), ", p-value= ", round(spearman_p_value,4),sep=''))+
  ggtitle(plot_title)+xlab(paste('Residual of ',var))+ylab(paste('Residual of ',var_to_correlate_with))+
  theme(axis.title.x=element_text(size=12),axis.title.y=element_text(size=12))
  print(p)
  
}

 if (phylogenetic_correction=='no'){
    partial_pearson_corr_result_df[,'Pearson adj. p-value']=p.adjust(partial_pearson_corr_result_df[,'Pearson p-value'],method='BH')
    partial_pearson_corr_result_df[,'Spearman adj. p-value']=p.adjust(partial_pearson_corr_result_df[,'Spearman p-value'],method='BH')
    print(partial_pearson_corr_result_df)
 }


#### Correaltion matric between the residuals after removing effects of partial correlation

corr_matrix=rcorr(as.matrix(d_after_partial_corr))
corr_df=ggcorrmat(data=d_after_partial_corr,matrix.type = 'lower',sig.level=0.05,output='dataframe')
ggcorrmat(data=d_after_partial_corr,matrix.type = 'lower',sig.level=0.05,output='plot')


## Create barplot for all traits corrected for mutation rate
partial_pearson_corr_result_df <- partial_pearson_corr_result_df %>% 
  dplyr::mutate(signi_star = case_when(`Pearson p-value`<= 0.001 ~ "***",
                                       `Pearson p-value` <= 0.01 ~ "**",
                                       `Pearson p-value` <= 0.05 ~ "*",
                                       `Pearson p-value` <= 0.1 ~ ".",
                                       `Pearson p-value` <= 1 ~ " "))

partial_pearson_corr_result_df[,'variables']=rownames(partial_pearson_corr_result_df)

partial_pearson_corr_result_df_ordered=partial_pearson_corr_result_df[order(partial_pearson_corr_result_df[,"Pearson's R"]),]
ggplot(data=partial_pearson_corr_result_df,
       aes(x = reorder(variables,`Pearson's R`), y = `Pearson's R`, fill = (`Pearson adj. p-value`)))+
    geom_bar(stat = "identity", width = 0.5)+
    scale_fill_gradient(low = "darkblue", high = "skyblue")+
    ylim(-1,1)+
    theme_classic()+
    theme(plot.title = element_text(hjust = 0.5),
          legend.position = c(0.1, 0.8),
          legend.box.background = element_rect(colour = "black"),
          axis.title.x = element_blank(),
          text = element_text(size = 12),
          # axis.title.y = element_blank(),
          # axis.text.x = element_blank(),
          # axis.text.y = element_blank())+
          axis.text.x = element_text(angle = 45, vjust = 1,
                                     size = 12, hjust = 1))+
    labs(fill='FDR')+
    ggtitle(plot_title)+#"Partial Pearson correlation of traits with lifespan \n without somatic mutation rate and mass-specific BMR")+
    ylab(paste("Partial Pearson correlation with ",var_to_correlate_with))+
    annotate("text", x = partial_pearson_corr_result_df$variables, 
            y = partial_pearson_corr_result_df$`Pearson's R`+(0.05*sign(partial_pearson_corr_result_df$`Pearson's R`)), 
            label = round((partial_pearson_corr_result_df$`Pearson adj. p-value`),5), 
           size = 4, color = "black")


```


####  Partial correlation analysis with bootstrap to compare Pearson's R's P-value distributions between traits

```{r fig.width=6, fig.height=2.5}

### Names of the variables we want to include in the analysis
partial_corr_colnames=c('log_lifespan','log_mutation_rate','log_respiratory_rate','log_heart_rate','log_adult_mass',
                        'log_time_to_sexual_maturity_female','log_time_to_sexual_maturity_male','litter_size',
                        'log_mass_specific_BMR')#'log_mass_specific_BMR')#,'log_basal_metabolic_rate')
                        


#partial_corr_colnames=assessed_traits

### Determine if phylogenetic correction is wanted
phylogenetic_correction='no'


### Select variables to regress out
var_to_regress_out=c('log_mutation_rate')
#log_adult_mass,'log_basal_metabolic_rate',log_mass_specific_BMR,log_mutation_rate,'log_mutation_rate','mass_specific_BMR'


### Select variable to correlate with (=variable on the y-axis)
var_to_correlate_with=c('log_lifespan') # log_lifespan,log_mass_specific_BMR,log_heart_rate

## Create list of variables to loop through -> drop the variables that are used in regression
vars_to_loop_through=partial_corr_colnames[!is.element(partial_corr_colnames,c(var_to_regress_out,var_to_correlate_with))]
#vars_to_loop_through=c('log_mass_specific_BMR','log_heart_rate')


## Created nested list for collecting the results of bootstrapping
bootstrapped_results=list()
result_names_list=c("Pearson's R",'Pearson p-value',"Spearman's R",'Spearman p-value','adj. Pearson p-value','adj. Spearman p-value')

for (i in 1:length(vars_to_loop_through)) {
  bootstrapped_results[[vars_to_loop_through[i]]] = replicate(length(result_names_list), list(), simplify = FALSE)
  names(bootstrapped_results[[vars_to_loop_through[i]]])=result_names_list
}  



## Create bootsrapped dataset
bootstrapped_samples <- list()
num_samples <- 1000
r_squared_mutation_only <- c()
r_squared_mutation_heart <- c()

set.seed(1)
for (i in 1:num_samples) {
  bootstrapped_sample <- sample_n(d, size = nrow(d), replace = TRUE)
  bootstrapped_samples[[i]] <- bootstrapped_sample
}


### Loop over bootstrapped dataset and calculate the Partial correlation for each dataset and collect the results 
for (bootstrapped_d in bootstrapped_samples){
  
  ##### CALULCATION OF R^2 COMPARISON
  ## Calculate the adjusted R^2 values of the 2 models and save them in vectors
  somatic_fit <- lm((log_lifespan) ~ (log_mutation_rate), data = bootstrapped_d)
  stats_somatic_fit <- glance(somatic_fit)
  r_squared_mutation_only <- c(r_squared_mutation_only, stats_somatic_fit$adj.r.squared)
  somatic_heart_fit <- lm((log_lifespan) ~ (log_heart_rate) + (log_mutation_rate), data = bootstrapped_d)
  stats_somatic_heart <- glance(somatic_heart_fit)
  r_squared_mutation_heart <- c(r_squared_mutation_heart, stats_somatic_heart$adj.r.squared)
  
  
  ###### CALCULATION OF PEARSON CORRELATION
  ## Initialize dataframe to collect the partial pearson correlation results into if no phylogenetic correction
  partial_pearson_corr_result_df=data.frame(matrix(NA,ncol=length(result_names_list),nrow=length(vars_to_loop_through),
                                                 dimnames=list(vars_to_loop_through,result_names_list)))
  colnames(partial_pearson_corr_result_df)=result_names_list
  
  ### Loop through remaining variables and perform the steps described above in points 3-5.
  for (var in vars_to_loop_through){
  
    # Drop datapoints that are NAN and select only numeric columns + necessary metadata: 
    # Species common name + nutrition + litter_size + body_temperature
    df=bootstrapped_d[!is.na(bootstrapped_d[,var]),]
    df=as.data.frame(df)
    df=df[,c(partial_corr_colnames,'common_name','species_name')]
    #df=df[!is.element(rownames(df),c('Felis_catus')),] #'Felis_catus'
   
  
    ###  Create linear models in order to regress out variables
    # Create formula necessary for regressing out 'var_to_regress_out'
    vars_to_regress_out_form=paste(var_to_regress_out,collapse='+')
    form_regress_out=as.formula(paste(c(var_to_correlate_with,vars_to_regress_out_form),collapse='~'))
    # Create formula necessary for regressing out 'var'
    form_var=as.formula(paste(c(var,vars_to_regress_out_form),collapse='~'))
    
    # Check if phylogenetic correction is yes/no
    if (phylogenetic_correction=='no'){
      ## Execute partial correlation function and save + print result 
      
      ## If during the calculation of correlations unreliable R or p-values are calculated due to encountering singularity in the     
      #  variance-covariance matrix, set those R and p-values as NaNs
      
      # Pearson partial correlation
      possibleError=tryCatch({pearson_res=(pcor.test(df[,var_to_correlate_with],df[,var],df[,var_to_regress_out],method='pearson'))
                pearson_r=pearson_res$estimate
                pearson_p_value=pearson_res$p.value
                },error=function(e){return(e)},
                warning=function(w){return(w)})
      if(inherits(possibleError, "error")|inherits(possibleError, "warning")){
        pearson_r=NA
        pearson_p_value=NA}
      
      # Spearman partial correlation
      possibleError=tryCatch({spearman_res=(pcor.test(df[,var_to_correlate_with],df[,var],df[,var_to_regress_out],method='spearman'))
                spearman_r=spearman_res$estimate
                spearman_p_value=spearman_res$p.value
                },error=function(e){return(e)},
                warning=function(w){return(w)})
      if(inherits(possibleError, "error")|inherits(possibleError, "warning")){
        spearman_r=NA
        spearman_p_value=NA}
  
      ## Add results to dataframe
      partial_pearson_corr_result_df[var,]=c(pearson_r,pearson_p_value,spearman_r,spearman_p_value,NA,NA)
      
      # Crate title of plot
      plot_title=paste(c('Corrected for:',paste(var_to_regress_out,collapse='+')),collapse=' ')
    }
    
  }
  partial_pearson_corr_result_df[,'adj. Pearson p-value']=p.adjust(partial_pearson_corr_result_df[,'Pearson p-value'],method='BH')
  partial_pearson_corr_result_df[,'adj. Spearman p-value']=p.adjust(partial_pearson_corr_result_df[,'Spearman p-value'],method='BH')

  for (rown in rownames(partial_pearson_corr_result_df)){
    for (coln in colnames(partial_pearson_corr_result_df))
      bootstrapped_results[[rown]][[coln]]=append(bootstrapped_results[[rown]][[coln]],partial_pearson_corr_result_df[rown,coln])
  }
}
saveRDS(bootstrapped_results,"bootstrapped_partial_corr_results.rds")


### COMPARISON OF UNIVARIATE (lifespan~somatic_mutation_rate) AND MULTIVARIATE REGFRESSION MODELS' R^2 VALUES  (lifespan~somatic_mutation_rate+resting_heart_rate) WITH BOOTSRAPPING ANALYSIS
# Bootstrapping Analysis
# r_squared_mutation_only <- c()
# r_squared_mutation_heart <- c()
# # bootstrap 1000 times
# for (i in 1:1000){
#   bootstrapped_data <- dplyr::sample_n(d, size = 15, replace = T)
#   somatic_fit <- lm(log10(log_lifespan) ~ log10(log_mutation_rate), data = bootstrapped_data)
#   stats_somatic_fit <- glance(somatic_fit)
#   r_squared_mutation_only <- c(r_squared_mutation_only, stats_somatic_fit$adj.r.squared)
#   somatic_heart_fit <- lm(log10(log_lifespan) ~ log10(log_heart_rate) + log10(log_mutation_rate), data = bootstrapped_data)
#   stats_somatic_heart <- glance(somatic_heart_fit)
#   r_squared_mutation_heart <- c(r_squared_mutation_heart, stats_somatic_heart$adj.r.squared)
# }
saveRDS(r_squared_mutation_heart, "bootstrapped_r_squared_mutation_heart.rds")
saveRDS(r_squared_mutation_only, "bootstrapped_r_squared_mutation_only.rds")
```

```{r}
table(bootstrapped_samples[[1]]['common_name'])
table(bootstrapped_samples[[2]]['common_name'])

```


### Plot the results of partial correlation bootsrapping analysis
```{r fig.width=6, fig.height=2.5}
bootstrapped_results=readRDS("bootstrapped_partial_corr_results.rds")

# function to extract legend from plot
get_only_legend <- function(plot) {
  plot_table <- ggplot_gtable(ggplot_build(plot))
  legend_plot <- which(sapply(plot_table$grobs, function(x) x$name) == "guide-box")
  legend <- plot_table$grobs[[legend_plot]]
  return(legend)
}


vars_to_compare=c('log_heart_rate','log_mass_specific_BMR')
#vars_to_compare=vars_to_loop_through[which(vars_to_loop_through!='log_mutation_rate')]
my_cols=qualitative_hcl(length((vars_to_compare)),palette = "Pastel 1") 


plot_list=list()
#wilcox_p_list=list()

for (log_transform_p in c(FALSE,TRUE)){
  for (correlation_result_metric in result_names_list){
    plot_df=data.frame()
    
    ## Set significance lvel to draw in the plot as a vertical line
    if (grepl('adj', correlation_result_metric,fixed=TRUE)){
      #print('YES')
       sign_level=0.2
    } else {sign_level=0.05}
    

    ## Create dataframe out of the bootstrapped results of the variables considered for the plot
    for (var in vars_to_compare){
        plot_df=rbind(plot_df,unlist(bootstrapped_results[[var]][[correlation_result_metric]]))}
      
    ## Rename colnames and omit NAN values  
    plot_df=t(plot_df)
    colnames(plot_df)=vars_to_compare
    rownames(plot_df)=NULL
    plot_df=na.omit(plot_df)
    
    ## Compare the two variables' distribution with Wilcoxon test
    #wilcox_p_val=wilcox.test(plot_df[,vars_to_compare[1]], plot_df[,vars_to_compare[2]])$p.value
    
    ## Melt plot_df to make coloring of the two distribtions easier in ggplot
    melted_df=melt(plot_df)
    colnames(melted_df)=c('Bootstrap_number','variable','value')
    
    ## Calculate the -log10 transforms of p-vales and significance levels
    if (log_transform_p==TRUE){
        melted_df$value=-log10(melted_df$value)
        x_label=gsub('p-value','-log10(p-value)',correlation_result_metric)
        sign_level=-log10(sign_level)
    } else {x_label=correlation_result_metric}
    
    ## Create ggplot
    p=ggplot(data=melted_df,aes(x = value, fill = variable,y=..density..)) +
            geom_histogram(alpha = 0.5,position="identity") +
            geom_density(alpha = 0.25)+
            labs(x=x_label)+
            theme(legend.position="none",
                  axis.title.x=element_text(size=15),
                  panel.background = element_rect(fill = "white"),
                  axis.line.y.left =  element_line(color = "black"),
                  axis.line.x.bottom = element_line(color = "black"))+
            geom_vline(xintercept = sign_level,  color="red", 
                       linetype="dashed", size=1)
     
     #  # Calculate x and y range of the plot for showing Wilcoxon p-value
     #  plot_range <- ggplot_build(p)$layout$panel_params[[1]]$y.range
     #  x_range <- ggplot_build(p)$layout$panel_params[[1]]$x.range
     # 
     # #  Define x and y coordinates for the text label
     #  x_coord <- x_range[1] + 0.7 * diff(x_range)
     #  y_coord <- plot_range[1] + 0.7 * diff(plot_range)
     #  p=p + annotate('text',x = x_coord, y = y_coord,label=paste('Wilcoxon p-value\n',wilcox_p_val))
  
    
    ## Clean up names of variables 
    legend_labels=gsub('_',' ',vars_to_compare)
    legend_labels=gsub('log','',legend_labels)
    legend_labels=gsub('heart','resting heart',legend_labels)
    legend_labels=tools::toTitleCase(tolower(legend_labels))
    legend_labels=gsub('Mass Specific Bmr','Mass-Specific BMR',legend_labels)
    
    ## Create a plot only to extract the legend from it that willbe shown on the plot_grid object at the end
    plot_for_legend=ggplot(data=melted_df,aes(x = value, fill = variable,y=..density..)) +
            geom_histogram(alpha = 0.7,position="identity") +
            geom_density(alpha = 0.25)+
            theme(legend.background = element_rect(fill = NA))+
            scale_fill_manual(name='Trait',labels = legend_labels, values=my_cols)+
            theme(legend.text = element_text(size=15),
                  legend.title = element_text(size=17))+
            ggtitle(correlation_result_metric)
    
    ## Save created plots and legends in a list
    plot_list[correlation_result_metric]=list(p)
    #wilcox_p_list[correlation_result_metric]=wilcox_p_val
    combined_legend=get_only_legend(plot_for_legend)
  }
  
  ## Add the 2 ggplots objects to a plot_grid object + add legend in the second step
  p2=plot_grid(plotlist = plot_list[c('Pearson p-value','adj. Pearson p-value')],ncol = 2)
  p2_with_legend=plot_grid(p2,combined_legend,ncol = 2,rel_widths = c(1, 0.25))
  
  ## Create title for the final plot
  subplot_title <- ggdraw() + draw_label(paste0('Significance levels of partial correlation with lifespan after \ncorrecting for somatic mutation rate (',num_samples,' resamples)'),size = 20,fontface='bold') #
                   #draw_text(subplot_letter, x=0.05,y=0.5,size = 15,fontface='bold') 
        
  ## Add title to plot
  plots_with_legend_title=plot_grid(subplot_title, p2_with_legend, ncol=1, rel_heights=c(0.07, 0.49),scale = 1)
  print(plots_with_legend_title)
}  


```

### Plot the results of linear regression-R^2 bootsrapping analysis
```{r fig.width=2.5, fig.height=2.5}
r_squared_mutation_heart=readRDS("bootstrapped_r_squared_mutation_heart.rds")
r_squared_mutation_only=readRDS("bootstrapped_r_squared_mutation_only.rds")

plot_df <- data.frame(
  'Model type' = c( rep("Somatic mutation rate only", 1000), rep("Somatic mutation rate + \nResting heart rate", 1000) ),
  value = c( r_squared_mutation_only, r_squared_mutation_heart),check.names = FALSE
)

## Create ggplot
p=ggplot(data=plot_df,aes(x=value, fill=`Model type`,y=..density..)) +
        geom_histogram(alpha = 0.5,position="identity") +
        geom_density(alpha = 0.25)+
        labs(x='adj. R-squared values')+
        theme(legend.position=c(0.3,0.8),
              axis.title.x=element_text(size=15),
              panel.background = element_rect(fill = "white"),
              axis.line.y.left =  element_line(color = "black"),
              axis.line.x.bottom = element_line(color = "black"),
              plot.title = element_text(size = 13, face = "bold",hjust = 0.5)) +
        ggtitle('Adj. R-squared values of two models \npredicting lifespan (1000 resamples)') 

print(p)
```



### Check the validity of the equation B=E2019 * Heart_rate * Body_mass


##    Based on Escala et al (2022) http://dx.doi.org/10.1038/s41598-022-06390-6:
##    Calculate the two sides of the empirical equation they derived based on the condition 
##    that the number of resp. cycles in a lifetime is constant among species  +  novel equation for metabolic rate (B=E2019 * Heart_rate * Body_mass)
##    y:'exp(Ea/KTa) * B * Tlife/a [kJ]'
##    x: E2019 * exp(Ea/KTa) * Nr *M [kJ]

##    Ea: activation energy (eV)
##    B: Metabolic rate (J)
##    E2019: fitted oxygen absorption rate 
##    K: Boltzmann's constant
##    Ta: ambient temperature
##    Tlife: lifespan
##    a: heart rate/respiratory rate
##    Nr: number of respiratory cycles in a lifetime
##    M: body mass 

```{r}


## Calculate ratio of heart rate/respiratory rate 
d[,'heart_rate_resp_rate_ratio']=d[,'mean_bpm']/d[,'mean_respiratory_rate_brpm']

## Calculate total heartbeats and total respiratory cycles in lifetime from the data found in the table
d[,'total_heartbeats_in_lifetime']=d[,'mean_bpm']*60*24*365*d$`Lifespan_80 (y) [Species 360/Human Mortality Database]`
d[,'total_respiratory_cycles_in_lifetime']=d[,'mean_respiratory_rate_brpm']*60*24*365*d$`Lifespan_80 (y) [Species 360/Human Mortality Database]` 
d[,'log_total_respiratory_cycles_in_lifetime']=log10(d[,'total_respiratory_cycles_in_lifetime'])


## Based on Escala et al (2022) http://dx.doi.org/10.1038/s41598-022-06390-6:
## Calculate the two sides of the empirical equation they derived based on the condition that the number of resp. cycles is constant + 
## novel equation for metabolic rate
## y:'exp(Ea/KTa)*B*Tlife/a [kJ]'
## x: E2019*exp(Ea/KTa)*Nr*M [kJ]

Ta=273+37
Ea=0.63*1.602*10^-19
K=1.38*10^-20
E2019=0.001

d[,'y']=exp(Ea/(K*Ta))*(d[,'BMR (kcal/kg BW/day)'])*(d[,'Adult mass (g)']/1000)*(d$`Lifespan_80 (y) [Species 360/Human Mortality Database]`)*365*4184/(4.5*1000)
d[,'x']=0.001*exp(Ea/(K*Ta))*1.62*10^8*d[,'Adult mass (g)']/1000 

d[,'log_y']=d[,'y']
d[,'log_x']=d[,'x']


#+d=d[!is.element(d$Species,c('Cow')),]

## Calculate correlations
pearson_res <- cor.test(d$x, d$y,method = "pearson")
spearman_res <- cor.test(d$x, d$y,method = "spearman")

## Plot the association between the 'y' and 'x' values previously calculated based on Escala (2022)
ggplot(data=d,aes_string(x="x",y='y'))+geom_point(aes(colour=nutrition))+
  geom_smooth(formula = y ~ 0+x,method='lm')+
   stat_poly_eq(formula = y ~ 0+x, 
                aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE) +
  geom_text_repel(aes_string(label = '`common_name`'),max.overlaps = Inf)+
  xlab('E2019*exp(Ea/KTa)*Nr*M [kJ]')+ylab('exp(Ea/KTa)*B*Tlife/a [kJ]')+
  geom_abline(intercept = 0, slope = 1,color='red',linetype=5)+
  annotate('label',x=8*10^6,y=2.5*10^4,label=paste('Pearson: R = ',round(pearson_res$estimate,2),', p-value=',
            round(pearson_res$p.value,4),
            "\nSpearman: R = ", round(spearman_res$estimate, 2), ", p-value = ", round(spearman_res$p.value,4),sep=''))+
  scale_x_continuous(trans='log10',limits=NULL)+ scale_y_continuous(trans='log10',limits=NULL)#+
  #xlim(0,1*10^20)+ ylim(0,1*10^20)

```


```
```

### PLot the correlation matrix between the life history traits
```{r fig.width=4, fig.height=4}
life_traits=c('met_rate','mutation_rate','respiratory_rate','heart_rate','adult_mass','time_to_sexual_maturity_female',
              'time_to_sexual_maturity_male','Litter_size')

log_life_traits=c('log_met_rate','log_mutation_rate','log_respiratory_rate','log_heart_rate','log_heart_rate',
                  'log_time_to_sexual_maturity_female','log_time_to_sexual_maturity_male','log_litter_size')

corr_colnames=c('log_lifespan','log_met_rate','log_mutation_rate','log_respiratory_rate','log_heart_rate','log_adult_mass',
                'log_time_to_sexual_maturity_female','log_time_to_sexual_maturity_male','Litter_size','log_basal_metabolic_rate')

corr_matrix=rcorr(as.matrix(d[,assessed_traits]))
corr_df=ggcorrmat(data=d[,assessed_traits],matrix.type = 'lower',sig.level=0.05,output='dataframe')
ggcorrmat(data=d[,assessed_traits],matrix.type = 'lower',sig.level=0.05,output='plot')

r=as.data.frame(corr_matrix$r)
r_abs=abs(r)
p=as.data.frame(corr_matrix$P)
```





### Check the significance of the traits as a second explanatory variable next to mutation rate inculded in the multivariate linear regression
```{r}
get_lm_coeff_sign=function(d,indices,form){
  data=d[indices,]
  model_mut_rate_ratio=lm(formula=form,data=data)
  p_val=(summary(model_mut_rate_ratio)$coefficients[,"Pr(>|t|)"][3])
  coef=(summary(model_mut_rate_ratio)$coefficients[,"Estimate"][3])
  return (p_val)
}
for (var in c('log_met_rate','log_respiratory_rate','log_heart_rate','log_adult_mass',
                'log_time_to_sexual_maturity_female','log_time_to_sexual_maturity_male','log_litter_size')){
  form=as.formula(paste(c('log_lifespan~log_mutation_rate',var),collapse='+'))
  boot_p_val=boot(data=d,statistic = get_lm_coeff_sign,R=1000,form=form)
  boot_p_val_ci=boot.ci(boot_p_val)
  
  hist(boot_p_val$t,main=var,xlim=c(0,1),probability =F,breaks=20)
  #print(var)
  #print(boot_p_val_ci$bca[4:5])
  #print(paste(var,boot_p_val$t))
}

```



### 1.PLot phylogenetic tree of species with 3 main branches color coded
### 2. PLot heatmap of traits, where only the traits get clustered, the species have the same order as on the phylo. tree
### 3. PCA of traits with the main branches indicated 
```{r fig.width=13.5,fig.height=17.5}
library("gplots")
library(devtools)
library(ggtree)
library(cowplot)
library(colorspace)
library("ggplotify")
library(ggheatmap)
#install.packages('ComplexHeatmap')
#install_github("jokergoo/ComplexHeatmap")
library('ComplexHeatmap')
#devtools::install_github("gdmcdonald/notly")
library(pheatmap)

## Initialize column names to include in Phyl.tree plot,Heatmap ,PCA

pca_colnames=c('log_lifespan','log_mutation_rate','log_respiratory_rate','log_heart_rate','log_adult_mass','log_time_to_sexual_maturity_female',
                'log_time_to_sexual_maturity_male','litter_size','log_basal_metabolic_rate') #'log_mass_specific_BMR

## Extract data from dataframe containing all the data
d_num_for_pca=d[,pca_colnames]
rownames(d_num_for_pca)=gsub('_',' ',d[,'common_name'])
res.pca=PCA((d_num_for_pca),graph=F)

## Add non-numeric data 
d_num_for_pca['species_name']=rownames(d_num_for_pca)
d_num_for_pca[,'nutrition']=d[,'nutrition']
d_num_for_pca[,'phyl_tree_main_branch']=as.factor(d[,'phylogenetic_tree_main_branch'])
d_num_for_pca[,'phylogenetic_grandorder_order']=d[,'phylogenetic_grandorder_order']

# Create the same order of species as seen in the phyl. tree plot
name_order=c('Panthera_tigris','Panthera_leo','Felis_catus','Mustela_putorius','Canis_lupus_familiaris','Equus_caballus','Giraffa_camelopardalis','Bos_taurus',
            'Rattus_norvegicus','Mus_musculus','Heterocephalus_glaber','Oryctolagus_cuniculus','Homo_sapiens','Colobus_guereza','Lemur_catta')




my_cols=qualitative_hcl(length(unique(d$phylogenetic_grandorder_order)),palette = "Dark 3") 

## Delelete the '_' character from the names of the species
tree_for_ggplot=tree
tree_for_ggplot$tip.label=d[match(tree$tip.label,d$species_name),'common_name']

## Set the main branch label for the tree
branch_groups=list()

for (group in (unique(d$phylogenetic_grandorder_order))){
  species_in_group=d[d$phylogenetic_grandorder_order==group,'common_name']
  species_in_group=gsub('_',' ',species_in_group)
  branch_groups[[group]]=unlist(species_in_group)
}

## Sort list by names  to give Branch 1, Branch 2, Branch 3
branch_groups=branch_groups[c('Carnivora','Ungulata','Rodentia','Lagomorpha','Primates')]

# Create new tree where groups are added to the tree itself
tree_for_ggplot <- groupOTU(tree_for_ggplot, branch_groups)

### PLOT PHYLOGENETIC TREE
treeplot=ggtree(tree_for_ggplot,aes(color=group),size=2)+
      geom_tiplab(size=12,show.legend = FALSE)+
      theme(plot.margin = unit(c(1,3,3,-15), "cm"),
            legend.text = element_text(size=28,face='bold'),
            legend.key.size = unit(1.9, 'cm'),
            legend.position=c(0.465,0.8),
            legend.title=element_text(size=33,face='bold'))+
      xlim(-100,150)+ylim(0,18.5)+
      scale_color_manual(name=NULL,values=c(my_cols,'black'), breaks=names(branch_groups))+
      guides(override.aes = aes(label = ""),color = guide_legend(override.aes = list(linetype = 0, size=15)))+
      annotate("text", label = "bold(a)", x = 0, y = 18.5,size=20,parse=TRUE)




## Reorder dataframe for heatmap visualization according to phyl.tree order
data_for_heatmap=d[match(get_taxa_name(treeplot),d$common_name),pca_colnames]
rownames(data_for_heatmap)=gsub('_',' ',get_taxa_name(treeplot))

## Rename specific metabolic rate, drop W_per_g from the end
colnames(data_for_heatmap)[grepl('spec_metabolic',colnames(data_for_heatmap))]='log_mass_specific_BMR'

## Reshape one string and add Female and Male symbol
rownames(data_for_heatmap)[grepl('colobus',rownames(data_for_heatmap))]='Black-and-white\ncolobus'
colnames(data_for_heatmap)[grepl('female',colnames(data_for_heatmap))]=paste0('log_time_to_sexual_maturity_','\U2640')
colnames(data_for_heatmap)[grepl('male',colnames(data_for_heatmap))]=paste0('log_time_to_sexual_maturity_','\U2642')

## Substitute underscore for space and capitalize the strings
colnames(data_for_heatmap)=gsub('_',' ',colnames(data_for_heatmap))
colnames(data_for_heatmap)=tools::toTitleCase(tolower(colnames(data_for_heatmap)))
colnames(data_for_heatmap)=gsub('Mass Specific Bmr','Mass-Specific BMR',colnames(data_for_heatmap))


## PLOT HEATMAP OF TRAITS
hmap=Heatmap((scale(data_for_heatmap)),
             rect_gp = gpar(col = "black", lwd = 4),
             color=colorRampPalette(c("navy", "white", "red"))(3),
             cluster_rows=FALSE,
             row_split=factor(d[match(get_taxa_name(treeplot),d$common_name),'phylogenetic_grandorder_order'],
                                 levels=c('Carnivora','Ungulata','Rodentia','Lagomorpha','Primates')),
             row_gap = unit(10, "mm"),
             row_title=c(NULL),
             row_names_gp = gpar(col=my_cols,fontsize = 32),
             column_names_gp = gpar(fontsize = 26),
             column_names_side = "top",
             row_names_side = "left",
             column_dend_height = unit(30, "mm"),
             column_dend_side = "bottom",
             column_dend_gp=gpar(lwd=5),
             width = ncol(data_for_heatmap)*unit(22, "mm"), 
             height = nrow(data_for_heatmap)*unit(23, "mm"),
             column_names_rot = 45,
             heatmap_legend_param = list(title='Scaled\nvalues\n',
                                         title_gp = gpar(fontsize = 25,fontface='bold'),
                                         title_position = "topcenter",
                                         direction = "vertical",
                                         labels_gp= gpar(fontsize = 20,fontface='bold'),
                                         legend_height = unit(8, "cm"),
                                         grid_width = unit(2, "cm")))

hmap=as.ggplot(hmap)+annotate("text", label = "bold(b)", x = 0.02, y = 0.95,size=20,parse=TRUE)#+
                    #theme(plot.margin = unit(c(1,1,0,5),"cm"))

### PLOT PCA
labels_for_pca=paste('Branch',d_num_for_pca[,'phyl_tree_main_branch'],sep=' ')

labels_for_pca=factor(d[,'phylogenetic_grandorder_order'],
                                 levels=c('Carnivora','Ungulata','Rodentia','Lagomorpha','Primates'))

pca_plot=fviz_pca_ind(res.pca,axes = c(1,2),repel=T,col.ind=labels_for_pca,
                      palette=my_cols,labelsize = 12,pointsize = 5,invisible="quali",pointshape=19)+             
                      theme(text = element_text(size = 30),
                            legend.title=element_text(size=28,face='bold'),
                            legend.text=element_text(size=32,face='bold'),
                            axis.title.x=element_text(size=25,face='bold'),
                            axis.text.x=element_text(size=20,face='bold'),
                            axis.text.y=element_text(size=20,face='bold'),
                            axis.title.y=element_text(size=25,face='bold'),
                            panel.background = element_rect(fill=rgb(0.3,0.23,0.34, alpha=0), colour='black'),
                            plot.margin = unit(c(-3,8,0,11),"cm"))+
                      scale_color_manual(name = '',labels = levels(labels_for_pca),values= my_cols)+
                      guides(color = guide_legend(override.aes = list(linetype = 0, size=9)))+
                      ggtitle('')+ 
                      ylim(c(-2.5,2.5))+xlim(c(-6,6))+
                      annotate("text", label = "bold(c)", x = -6, y = 2.5,size=20,parse=TRUE)

first_line=plot_grid(treeplot,hmap,ncol = 2)
whole_plot=plot_grid(first_line,pca_plot,nrow=2,rel_heights=c(0.6, 0.4),rel_widths=c(5,1))
print(whole_plot)
#plot_grid(p3,align = 'hv')

```

```{r}
anage=read.csv('data/original/AnAge_Data.txt',sep='\t')
lifespan=read.csv('data/original/Lifespan_Species360.txt',sep='\t')

print(anage[,c('Genus','Species')])

```



